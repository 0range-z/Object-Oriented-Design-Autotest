# Java多线程入门教程

在阅读这篇入门教程之前，我们假定你从来没有接触过多线程的概念，我们希望你能够通过阅读这篇教程，对多线程建立一个至少是感性的认识，以及能够使用Java的进行多线程编程，并且在此基础上掌握一些常见的多线程设计模式，为接下来的课程学习以及将来的实际开发奠定基础。

## 什么是线程

### 先说说“进程“

- 相信大家已经听说过了进程的概念，这里我们再简单回顾一下。我们写好的程序的源代码，通过编译器或者是解释器生成目标程序，即可以在处理器上被执行的程序。比如，大家不妨写一个`helloworld.c`，然后在终端执行`gcc/clang helloworld.c`，在当前目录下默认生成一个名为`a.out`的文件，被称为汇编程序输出（assembler output），接下来只要执行`./a.out`，即可执行此程序。
- 生成的这个程序在被操作系统执行之前是没有生命力的，它只是存储在计算机中的一个文件。而被操作系统分配资源、进行调度等一些列操作后，这个由这个程序产生了一种具有生命力的形式，即进程，进程同时也是操作系统进行资源分配的最小单位。
- 直观上来理解，我们在计算机中，每执行一个程序，操作系统都会由其创建对应的进程与我们交互，我们打开IDEA、Eclipse，都在系统中对应一个进程，大家如果感兴趣可以执行`ps aux`命令，看看自己的电脑上现在运行着哪些进程。

### 接下来说说”线程“

- 直观上来理解，线程是一个进程内部的一个“轻量级的进程”。使用IDEA和Eclipse时，我们一边敲着代码，同时IDE会进行语法检查、语法成分高亮、代码提示（IDEA甚至还会检查你的英文拼写有没有typo），而此时你还run着一个程序，在后台IDE又可能在检查IDE和plugin的更新。在一个进程里同时进行着很多个“子操作”，我们之前说过，“进程是操作系统进行资源分配的最小单位”，但是结合实际想一下，进程并不是任务调度和执行的基本单位，因为在一个进程的内部（上面说的IDEA和Eclipse），还有很多更小的单位（负责语法检查的模块、负责检查更新的模块那些），它们执行着各种各样的任务来满足用户的需求，这就是线程。

- 线程是任务调度和执行的基本单位，一个进程中有一个或多个线程，这些线程共享OS分配给进程的资源。
- 经过一学期计组的学习，相信大家对CPU的基本工作原理和流程有了一定的认识。实际上，对于只有一个CPU的计算机而言，无法实现进程之间真正的并行，因为一个处理器在同一时间只能对一个任务进行调度。但是，我们仍可以通过调度各进程使得其分时执行，每一个进程轮流执行一小段时间片，进而实现了微观上串行，宏观上并行。对于线程，这一点类似进程，因而线程也可以通过一定的调度算法实现至少在宏观上多个线程并行。

## 为什么要引入线程的概念

研究一个概念，我们往往要经历一个是什么$\rightarrow$为什么$\rightarrow$怎么做的过程，现在到了“为什么”的环节。为什么要引入线程的概念呢？相信通过上面的阅读，大家已经大致有了一个腹案。

- 还是用上面IDEA和Eclipse的例子，设想一下如果没有多线程，我们的系统只能够保证进程之间的宏观并行，而在一个进程内部，即使有多个任务也只能做到串行，这样，当IDE后台检查更新时前台的语法检查因为得不到调度，进而导致后台有任务进行，会影响我们写代码，而我们写代码的同时，不能执行后台任务。在一个程序中往往存在多个子任务，它们之间的执行是不会相互影响的，完全可以并行执行，如果没有线程的概念，这样的任务只能串行，就会使得一个程序运行低效，难以满足用户需求。所以线程的一个优点在于增加了程序内的并发性，提高程序的执行效率。
- 这里你可能会问，要想实现这样的并行，我可以让进程生成子进程，然后让系统进行进程的调度不就能实现并行了么？没错，但是CPU在收到中断信号时需要使用中断服务程序保存中断现场，然后再跳转到指定指令去执行。因此，在进程之间切换时，操作系统需要保存进程的上下文，比如进程中的各种变量的值、返回时执行的指令地址等等，然而前面我们说过，线程彼此共享进程的资源，而进程时系统分配资源的最小单位，因此切换线程的开销要比切换进程小。（这一点，如果我没记错的话，大家会在OS的Lab4中有更**深切**的体会）。
- 还有一些其他的原因，大家也会在操作系统课程中详细学习。

## 如何进行多线程编程——Java多线程入门

前面说的那些，都是为了能让大家建立一个关于线程的感性认识。而通过阅读之前的内容，相信大家已经意识到了，之前可能大家没接触过线程的概念，但是大家确确实实使用过线程，只不过大家写的程序运行后的进程中只有一个线程，就是main。所以我们要做的事，无非就是由单线程拓展为多线程。接下来，我们要进入正题，具体来看一看，如何使用Java进行多线程的开发。

## Thread类和Runnable接口

首先，向大家介绍Thread类和Runnable接口，通过继承Thread类**或者**实现Runnable接口是Java中构造线程的对象的常用方法。这里我们来做个类比。刚刚我们说过，之前大家写的程序，运行后只有一个线程，那就是main，现在，在`Main.java`中有着如下结构：

```java
public class Main {
    public static void main(String[] args) {
        // some codes
    }
}
```

即，对于一个线程的对象，在这个类中应当有一个入口函数，在`Main.java`中，这个入口函数是`public static void main(String[] args)`，它是main线程的入口，那么同理，对于我们自己创建的对象而言，这个对象里也应有一个入口函数，即`public void run()`。

当我们构造一个类，使其继承Thread类或者实现Runnable接口，这时我们要重写`public void run()`方法，其内容是当我们创建并执行这个线程时希望它执行的动作。下面使用继承Thread类的方法举个小例子。

```java
// Main.java
public class Main {
    public static void main(String[] args) {
        MultiThreadDemo t0 = new MultiThreadDemo("666");
        MultiThreadDemo t1 = new MultiThreadDemo("233");
        t0.start();
        t1.start();
    }
}
```

```java
// MultiThreadDemo.java
public class MultiThreadDemo extends Thread {
    private String threadName;

    public MultiThreadDemo(String name) {
        threadName = name;
    }

    public void run() {
        for (int i = 0; i < 100; i++) {
            System.out.println("Thread " + threadName + ": output number " + i);
        }
    }
}

```

这是一个没有任何意义的小程序，但是从输出结果我们就能看出我们创建的这两个对象化的线程在宏观上并行，它们输出可能会“彼此交融”，即从总体上看，每一条输出语句的执行顺序取决于线程的调度。这里大家可以提前了解一下`jProfiler`应用，通过它可以更加直观地看出当前执行的进程中的线程情况。

以上就是一个最简单的Java多线程的实现，然而我们还有一些需要提醒的地方。

- 首先，请不要将`run`和`start`方法混淆。`run`方法才是线程对象的“入口函数”，而`start`方法是启动线程，如果大家感兴趣，在IDEA中，按住Control键（在mac上是Commend键）点击`start`函数，可以大致明白其作用是将当前对象实例加入到`ThreadGroup`中，进而使线程得到调度。（如果大家还有兴趣，试试把上面的`run`函数删去，然后执行，会有什么现象，会报错么，为什么？）

- 其次，简单介绍一下这两种创建线程对象的方式的区别

  - 很显然，由于Java不允许**类**的多继承（但是接口之间是可以多继承的，想想为什么，同时可以看看那些支持类的多继承的语言，比如python，使用的是什么样的机制，可以搜索关键词`python 多继承 SMO`自行了解）。因此，使用实现Runnable接口的方式，可以使得这个线程对象继承别的类，而继承Thread类则不行。

  - 使用继承Thread类来实现，好处在于，要想获取当前正在被调度的线程，只要使用this即可，而使用实现借口的方式，则要使用`Thread.currentThread()`。同学们如果是刚刚接触可能对此体会不深，我们举个例子，在实现“生产者-消费者模型”（我们后面会介绍，这时多线程的设计模式之一）时，形象理解，如果仓库没有商品，而消费者线程来尝试取商品，那么它就要等待，直到生产者生产出一个商品后它被唤醒，这里让一个线程等待使用`wait()`方法，前者为`this.wait()`即可，后者要`Thread.currentThread().wait()`。

  - 其实，仿照之前的方法查看`Thread`类，可以看到

    ```java
    public
    class Thread implements Runnable {
        /* Make sure registerNatives is the first thing <clinit> does. */
        private static native void registerNatives();
        static {
            registerNatives();
        }
    
        private volatile char  name[];
        private int            priority;
        private Thread         threadQ;
        private long           eetop;
    
        /* Whether or not to single_step this thread. */
        private boolean     single_step;
      	... ... ... ...
    ```

    本质上`Thread`类也是实现了接口`Runnable`，可以理解为它是对于单纯实现`Runnable`接口，它封装了一些更加丰富的功能，具体内容欢迎大家查看`Thread`类自行探索。



好了，现在对于同学们而言，多线程也没那么神秘了，通过上面的方法，就能够实现一个最简单的Java多线程程序了，希望大家在此处暂停一下，动手实践一下，就用刚才了解到的一点内容自己写一个比上面那个无脑程序更有意义的程序。下面，我们再来学一些更多的内容吧。

### 共享资源的访问控制

#### 线程冲突

上面那个无脑程序没有遇到共享资源访问控制问题，因为每个线程的`run`方法中只会使用该对象实例的实例变量。但是在最开始我们也提到了，进程是操作系统分配资源的最小单位，而多个线程共享这个进程的资源。由于进程之间是并行的，所以遇到共享资源的访问时就有可能造成冲突。举个例子：

```java
public class CommonArea {
  	private x = 3;
  	private y = 4;
  	public static changeX() {
      	x = y + 1;
    }
  	public static changeY() {
      	y = x * 2;
    }
}
```

```java
public class MultiThreadDemo extends Thread {
    public void run() {
        CommonArea.changeX();
      	CommonArea.changeY();
    }
}
```

对于两个线程对象实例t0和t1，如果执行顺序是t0 changeX() t0 changeY() t1 changeX() t1 changeY()，则得到结果y为22，如果t0 changeX() t1 changeX() t0 changeY() t1 changeY()，则得到结果y为10，由于多线程之间调度顺序的不同，造成在访问公共变量后得到的结果不同，这样的例子还有很多。大家可以考虑一下，去掉上面的changY方法，CommentArea改为：

```java
public class CommonArea {
  	private x = 3;
  	public static changeX() {
      	x = x + 1;
    }
}
```

这样会出现线程冲突么？为什么？（提示：x = x + 1，实际上是先求x + 1的值，再对x进行赋值）



#### 访问控制

从上面的例子我们可以看到，之所以会出现线程之间的冲突，是因为线程之间缺乏执行顺序的约束，多个线程之间大部分过程是异步的，而在涉及到共享资源时需要对两个线程进行同步。比如对于改后的`CommonArea`的访问，由于在一个线程执行`x + 1`时可能被另一个线程打断，此时第一个线程中x值为3，因为只是求了`x + 1`的值但还没有赋值，如果另一个线程此时也执行`x + 1`，两个`x + 1`值均为4，最后赋值，得到x的值为4，这与我们期望相违背。所以我们要通过一种方式限制`x = x + 1`的执行，使其在线程之间同步，即一个线程在执行时其他线程必须等待执行完毕后才能执行，这样就避免了这个问题。

接下来我们看一下具体实现。在Java中，实现同步方法使用的是`synchronized `关键字，比如上面的CommonArea，只要改为

```java
public class CommonArea {
  	private x = 3;
  	public static synchronized changeX() {
      	x = x + 1;
    }
}
```

即可。这时，changeX方法是同步的，我们也可以形象地理解为此方法是一个不可以被其他进程打断的原子操作。

为了方便理解，这里我们介绍一个锁的概念，上面的过程，我们可以形象地理解为，一个线程调用changeX方法后，对这个方法上了一个锁，导致其他线程被挡在门外。当执行结束后，此线程释放锁，进而其他线程去争夺这个锁，抢到锁的锁住门，然后重复上述过程。

我们对我们的需求进一步扩展，上文中我们使用`synchronized`关键字，保证一个方法有线程在访问，则其他方法等待，直到其执行结束后才可访问。现在，我们希望能够认为决定满足什么条件让线程等待，即我们希望能够在线程间进行协作。这里介绍一对常用的方法，即`wait()`和`notifyAll()`，`wait()`方法表示让当前线程阻塞，即交出线程锁，然后进入等待状态。`notifyAll()`方法则与之相对，即唤醒在等待状态的线程。在同学们接下来的作业中，这一组操作会被经常用到，因为如果根据一个条件判断是否进入等待，以及判断是否被唤醒，比较粗糙的方法是使用暴力轮询，不断查看条件是否符合，但是这样势必会造成CPU时间的过度消耗，而`wait()`和`notifyAll()`则可以有效避免这个问题。同学们或许会觉得这里稍微有点抽象，没关系，马上我们就会介绍到多线程的设计模式，而首先被介绍的“生产者-消费者模式”的实现就会用到这一组操作，届时结合实例同学们就能够理解了。需要注意的是，`wait()`方法会抛出`InterruptedException `，因此，在使用时使用`try-catch`，即

```java
try {
	this.wait(); 
} catch (InterruptedException e) {
  // do something
}
```

此外，欢迎同学们自行查阅资料，了解`sleep() join()`方法，以及`notify()`与`notifyAll()`的区别，由于只是入门教程，一些知识还需要随着同学们实际操作时不断了解，所以此处按下不表。

